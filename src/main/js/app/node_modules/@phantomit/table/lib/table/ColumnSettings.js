"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(require("react"));
var antd_1 = require("antd");
var Cell_1 = require("./Cell");
var definition_1 = require("@phantomit/datasource/lib/utils/definition");
var excel_to_num = function (id) {
    var p = id.toUpperCase().match(/[A-Z]+/);
    return p == null || p.length === 0 ? undefined : p[0].split('').reduce(function (r, a) { return r * 26 + parseInt(a, 36) - 9; }, 0);
};
var num_to_excel = function (num) {
    var ret = '';
    for (var a = 1, b = 26; num != null && (num -= a) >= 0; a = b, b *= 26) {
        ret = String.fromCharCode(parseInt("" + (num % b) / a) + 65) + ret;
    }
    return ret;
};
var excel_to_index = function (id) {
    var num = excel_to_num(id);
    if (num)
        return num - 1;
    else
        return undefined;
};
var index_to_excel = function (num) { return num_to_excel(num + 1); };
exports.ColumnSettings = function (props) {
    var _a = react_1.default.useState({
        columns: JSON.parse(JSON.stringify(props.columns)),
        editor: undefined,
        edit: undefined
    }), opt = _a[0], setOpt = _a[1];
    var columns = [
        {
            title: "",
            dataIndex: "",
            width: 100,
            fixed: true,
            render: function (value, row, index) {
                return react_1.default.createElement(Cell_1.Action, { isEditing: opt.edit === index, onEdit: function () {
                        var row = JSON.parse(JSON.stringify(opt.columns[index]));
                        setOpt(__assign(__assign({}, opt), { editor: row, edit: index }));
                    }, onApply: function () {
                        var columns = opt.columns, editor = opt.editor, args = __rest(opt, ["columns", "editor"]);
                        if (editor)
                            columns[index] = editor;
                        setOpt(__assign(__assign({}, args), { columns: __spreadArrays(columns), editor: undefined, edit: undefined }));
                    }, onCancel: function () {
                        setOpt(__assign(__assign({}, opt), { editor: undefined, edit: undefined }));
                    } });
            }
        },
        {
            title: "Field",
            dataIndex: "dataIndex",
        },
        {
            title: "Display Name",
            dataIndex: "title",
            render: function (value, row, index) {
                return react_1.default.createElement(Cell_1.CellContent, { type: definition_1.ColumnType.string, value: opt.edit === index ? opt.editor && opt.editor["title"] : value, edit: opt.edit === index, formatted: value, onChange: function (value) {
                        var editor = opt.editor;
                        if (editor) {
                            editor["title"] = value;
                        }
                        setOpt(__assign(__assign({}, opt), { editor: editor }));
                    } });
            }
        },
        {
            title: "Visible",
            dataIndex: "visible",
            width: 120,
            render: function (value, row, index) {
                return react_1.default.createElement(Cell_1.CellContent, { type: definition_1.ColumnType.boolean, value: opt.edit === index ? opt.editor && opt.editor["visible"] : value, edit: opt.edit === index, formatted: (react_1.default.createElement(antd_1.Tag, { color: value ? "green" : "red", key: value ? 1 : 0 }, ("" + (value ? "visible" : "hidden")).toUpperCase())), onChange: function (value) {
                        var editor = opt.editor;
                        if (editor) {
                            editor["visible"] = value;
                        }
                        setOpt(__assign(__assign({}, opt), { editor: editor }));
                    } });
            }
        },
        {
            title: "Editable",
            dataIndex: "editable",
            width: 120,
            render: function (value, row, index) {
                return react_1.default.createElement(Cell_1.CellContent, { type: definition_1.ColumnType.boolean, value: opt.edit === index ? opt.editor && opt.editor["editable"] : value, edit: opt.edit === index, formatted: (react_1.default.createElement(antd_1.Tag, { color: value ? "green" : "red", key: value ? 1 : 0 }, ("" + (value ? "editable" : "locked")).toUpperCase())), onChange: function (value) {
                        var editor = opt.editor;
                        if (editor) {
                            editor["editable"] = value;
                        }
                        setOpt(__assign(__assign({}, opt), { editor: editor }));
                    } });
            }
        },
        {
            title: "Filter",
            dataIndex: "filter",
            width: 120,
            render: function (value, row, index) {
                return react_1.default.createElement(Cell_1.CellContent, { type: definition_1.ColumnType.boolean, value: opt.edit === index ? opt.editor && opt.editor["filter"] : value, edit: opt.edit === index, formatted: (react_1.default.createElement(antd_1.Tag, { color: value ? "green" : "red", key: value ? 1 : 0 }, ("" + (value ? "enable" : "disable")).toUpperCase())), onChange: function (value) {
                        var editor = opt.editor;
                        if (editor) {
                            editor["filter"] = value;
                        }
                        setOpt(__assign(__assign({}, opt), { editor: editor }));
                    } });
            }
        },
        {
            title: "Sort",
            dataIndex: "sorter",
            width: 120,
            render: function (value, row, index) {
                return react_1.default.createElement(Cell_1.CellContent, { type: definition_1.ColumnType.boolean, value: opt.edit === index ? opt.editor && opt.editor["sorter"] : value, edit: opt.edit === index, formatted: (react_1.default.createElement(antd_1.Tag, { color: value ? "green" : "red", key: value ? 1 : 0 }, ("" + (value ? "enable" : "disable")).toUpperCase())), onChange: function (value) {
                        var editor = opt.editor;
                        if (editor) {
                            editor["sorter"] = value;
                        }
                        setOpt(__assign(__assign({}, opt), { editor: editor }));
                    } });
            }
        },
        {
            title: "Width",
            dataIndex: "width",
            render: function (value, row, index) {
                return react_1.default.createElement(Cell_1.CellContent, { type: definition_1.ColumnType.int, value: opt.edit === index ? opt.editor && opt.editor["width"] : value, edit: opt.edit === index, formatted: value, onChange: function (value) {
                        var editor = opt.editor;
                        if (editor) {
                            editor["width"] = value;
                        }
                        setOpt(__assign(__assign({}, opt), { editor: editor }));
                    } });
            }
        },
        {
            title: "Import CSV Column Name",
            dataIndex: "schemaIndex",
            width: 120,
            render: function (value, row, index) {
                var str = index_to_excel(value);
                return react_1.default.createElement(Cell_1.CellContent, { type: definition_1.ColumnType.string, value: opt.edit === index ? opt.editor && opt.editor.schemaIndex !== undefined ? index_to_excel(opt.editor["schemaIndex"]) : undefined : str, edit: opt.edit === index, formatted: str, onChange: function (value) {
                        var editor = opt.editor;
                        if (editor) {
                            editor["schemaIndex"] = excel_to_index(value);
                        }
                        setOpt(__assign(__assign({}, opt), { editor: editor }));
                    } });
            }
        }
    ];
    return react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(antd_1.Modal, { visible: props.visible, centered: true, title: 'Column Configurations', width: "85vw", onCancel: props.onCancel, onOk: function () {
                props.onApply(opt.columns);
            } },
            react_1.default.createElement(antd_1.Table, { scroll: { y: '50vh', x: '80vw' }, rowKey: "dataIndex", columns: columns, pagination: false, size: "small", dataSource: opt.columns, rowClassName: function (r, index) { return opt.edit !== undefined && index !== opt.edit ? "ant-spin-blur" : ""; } })));
};
